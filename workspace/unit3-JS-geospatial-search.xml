<export><workspace name="unit3-JS-geospatial-search"><query name="exercise-1.1" focus="false" listorder="2" taborder="2" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 1.1: Create a geospatial element index for &lt;coordinates&gt;.

Go to the Admin GUI at localhost:8001, and navigate to 
Databases/mlw16-geo-wkshp/Geospatial Indexes/Geospatial Element Indexes, 
and click the "add" tab to add a new index. Leave the namespace URI blank, 
and type in the desired element name ("coordinates"). Set the coordinate 
system to wgs84.

Important Note: KML and GeoJSON store coordinates with longitude first, 
then latitude. So make sure to choose "long-lat-point" as the point format. 
Leave the remaining properties at their defaults.
*/</query><query name="exercise-1.2.sjs" focus="false" listorder="4" taborder="3" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 1.2: Create an index using the admin API.

Suppose your data is of the form:
&lt;location 
  latitude="37.7710611356079" 
  longitude="-122.453078855673"&gt;

To index this format we would set up an element-attribute-pair 
index. You can do this through the admin GUI, but here we will 
use the Admin API instead 
(https://docs.marklogic.com/guide/admin-api/usingAPI). You 
will need to use the functions:
  admin.getConfiguration (retreives the server configuration)
  admin.databaseGeospatialElementAttributePairIndex (creates an index specification)
  xdmp.database (returns the database ID given the database name)
  admin.databaseAddGeospatialElementAttributePairIndex (adds the index spec to the database)
  admin.saveConfiguration (saves the new configuration)
*/

var admin = require("/MarkLogic/admin");

var config = admin.getConfiguration();

var newConfig = //add the new index

admin.saveConfiguration(newConfig);</query><query name="exercise-1.2-sol.sjs" focus="false" listorder="6" taborder="5" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">var admin = require("/MarkLogic/admin");

var config = admin.getConfiguration();

var newIndex = admin.databaseGeospatialElementAttributePairIndex(
  "","location",  //parent element namespace URI + localname
  "","latitude",  //latitude element namespace URI + localname
  "","longitude", //longitude element namespace URI + localname
  "wgs84",        //coordinate system
  false           //range value positions
);

var newConfig = admin.databaseAddGeospatialElementAttributePairIndex(
  config, xdmp.database("mlw16-geo-wkshp"), newIndex);

admin.saveConfiguration(newConfig);</query><query name="exercise-1.3.sjs" focus="false" listorder="8" taborder="7" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 1.3: MarkLogic supports a variety of formats for indexing. 
These include element-pair, element-child, and XPath indexes.

Try to create a geospatial index for data in the format:
&lt;Point&gt;
  &lt;lat&gt;12.01&lt;/lat&gt;
  &lt;lon&gt;-125.10&lt;/lon&gt;
&lt;/Point&gt;

Use either the admin GUI at localhost:9001, or the admin API.
*/</query><query name="exercise-1.3-sol.sjs" focus="false" listorder="10" taborder="9" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
We should use a geospatial-element-pair-index for this format.
&lt;Point&gt;
  &lt;lat&gt;12.01&lt;/lat&gt;
  &lt;lon&gt;-125.10&lt;/lon&gt;
&lt;/Point&gt;

The code below shows how you would do this using the admin API.
*/
var admin = require("/MarkLogic/admin.xqy");
         
var config = admin.getConfiguration();

var newIndex = admin.databaseGeospatialElementPairIndex(
  "", "Point", //Element namespace URI and localname
  "", "lat",   //Latitude attribute namespace URI and localname
  "", "lon",   //Longitude attribute namespace URI and localname
  "wgs84",     //Coordinate system
  false        //Range value positions
);

var newConfig = admin.databaseAddGeospatialElementPairIndex(
  config, xdmp.database("mlw16-geo-wkshp"), newIndex);

admin.saveConfiguration(newConfig);</query><query name="exercise-1.4-homework" focus="false" listorder="11" taborder="10" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
In addition to the Admin GUI and the Admin API, MarkLogic also 
provides a REST-based interface for server management at 
localhost:8002/manage. For example, to see the properties of 
the mlw16-geo-wkshp database, visit the endpoint 
localhost:8002/manage/v2/databases/mlw16-geo-wkshp/properties

Exercise: Read more about the REST Management API 
(https://docs.marklogic.com/REST/management) and try using it 
to add, modify, or delete geospatial indexes.
*/</query><query name="exercise-2.1.sjs" focus="false" listorder="13" taborder="12" active="true" database="9059189350391337657" server="17543607842490988103" mode="javascript">/*
Exercise 2.1: Use the index we created in exercise 1.1 on the 
&lt;coordinates&gt; element to find all documents that contain a point 
within 1/2 mile of the point (37.770, -122.447).

Use a cts.elementGeospatialQuery with a cts.circle of radius 0.5.
Then use cts.search to search for all documents with matching 
points.
*/

var qry = //create a query here

cts.search(fn.doc(), qry);</query><query name="exercise-2.1-sol.sjs" focus="false" listorder="15" taborder="14" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">var center = cts.point(-122.447, 37.770);
var circle = cts.circle(0.5, center);

var qry = cts.elementGeospatialQuery(xs.QName("coordinates"), circle);

cts.search(qry);</query><query name="exercise-2.2.sjs" focus="false" listorder="17" taborder="16" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 2.2: A common use of geospatial queries in search 
applications is to limit search results to a map window. 
Suppose the map window has the following bounds:
south = 37.756
west  = -122.476
north = 37.785
east  = -122.421
Write a query that searches for the word "school", but limits 
the results to the map window. (As in the previous exercise, 
use the geospatial element index on &lt;coordinates&gt;.)

Use a cts:and-query to search for documents that satisfy both 
requirements. So documents must contain a given word (use a 
cts:word-query) and be in the specified geospatial bounds (use 
cts:element-geospatial-query with a cts:box).
*/

var qry = //create a query here

cts.search(qry);</query><query name="exercise-2.2-sol.sjs" focus="false" listorder="19" taborder="18" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">var window = cts.box(37.756,-122.476,37.785,-122.421);
var geoQry = cts.elementGeospatialQuery(xs.QName("coordinates"), window, "type=long-lat-point");

var wordQry = cts.wordQuery("school");

var qry = cts.andQuery((wordQry, geoQry));

cts.search(qry);</query><query name="exercise-2.3.sjs" focus="false" listorder="21" taborder="20" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 2.3: The following WKT-formatted polygon represents the 
North Beach neighborhood of San Francisco.
POLYGON((-122.406776 37.797577,-122.413818 37.796764,-122.415016 37.803818,-122.417076 37.805172,-122.409355 37.805580,-122.408493 37.799339,-122.406776 37.797577))

Write a query to count the documents in the database that contain 
coordinates in this neighborhood.

Compare the results you get using fn.count vs. cts.estimate.
*/
</query><query name="exercise-2.3-sol.sjs" focus="false" listorder="23" taborder="22" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">var poly = geo.parseWkt("POLYGON((-122.406776 37.797577,-122.413818 37.796764,-122.415016 37.803818,-122.417076 37.805172,-122.409355 37.805580,-122.408493 37.799339,-122.406776 37.797577))");

var qry = cts.elementGeospatialQuery(xs.QName("coordinates"), poly, "type=long-lat-point");

[
  cts.estimate(qry), 
  fn.count(cts.search(qry))
];
</query><query name="exercise-3.1.sjs" focus="false" listorder="25" taborder="24" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 3.1: Geospatial lexicon functions allow you to browse 
the points stored in a geospatial index. The simplest geospatial 
lexicon functions are cts.*GeospatialValues (where * is 
replaced by the type of index).

Use the cts.elementGeospatialValues function to see a list of the
points stored in the &lt;coordinates&gt; index we set up in exercise 1.1.

Important Note: By default, the geospatial lexicon functions only 
look for indexes of type "point". Remember that our index is of type 
"long-lat-point". So when using these functions you must supply the 
option "type=long-lat-point". 
*/
</query><query name="exercise-3.1-sol.sjs" focus="false" listorder="27" taborder="26" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">cts.elementGeospatialValues(xs.QName("coordinates"),null,"type=long-lat-point")

</query><query name="exercise-3.2.sjs" focus="false" listorder="29" taborder="28" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 3.2: The lexicon function cts.elementGeospatialValueMatch 
allows you to match specific points from the geospatial index. This
function returns points from the index; if you want the original 
documents, use the points to create a cts.elementGeospatialQuery.
You can also use cts.frequency on the result to determine how many 
documents contain the point. 

Use cts.elementGeospatialValueMatch and cts.frequency to determine 
how many documents contain the point: 
(-122.39399537822999,37.731322072312345).
*/</query><query name="exercise-3.2-sol.sjs" focus="false" listorder="31" taborder="30" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">var p = cts.point(-122.39399537822999,37.731322072312345);
cts.frequency(cts.elementGeospatialValueMatch(xs.QName("coordinates"), p, "type=long-lat-point"));</query><query name="exercise-3.3.sjs" focus="false" listorder="33" taborder="32" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 3.3: (a) The lexicon function cts.elementGeospatialBoxes
sorts the points in the index into box-shaped "buckets". Use this
function to sort the points in the index into 4 buckets, divided by
latitude 37.770 and longitude -122.447. The function will return a 
box for each of the 4 buckets.

(b) The function cts.frequency can be used on these boxes to 
determine how many points are contained in each box. Use 
cts.frequency to find the number of points in each of the boxes 
from part (a).

Note: This technique is useful for creating "heatmaps".
*/</query><query name="exercise-3.3-sol.sjs" focus="false" listorder="35" taborder="34" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">var results = [];
for (var box of 
  cts.elementGeospatialBoxes(xs.QName("coordinates"),
    [37.770], [-122.447],
    "type=long-lat-point")) {
  results.push([box, cts.frequency(box)]);
}
results;</query><query name="exercise-4.1.xqy" focus="false" listorder="36" taborder="35" active="true" database="9059189350391337657" server="3157198157855269707" mode="xquery">(: Please note that our Admin APIs are only available in XQuery :)

(:
The function cts:match-regions allows you to search 
for regions stored in documents. To use it, your data should be 
stored in WKT format, and you will need a string range index on the 
element that contains the WKT string.

Some of the documents in the database contain data in this format:
&lt;region&gt;POLYGON((-122.406776 37.797577,-122.413818 37.796764,-122.415016 37.803818,-122.417076 37.805172,-122.409355 37.805580,-122.408493 37.799339,-122.406776 37.797577))&lt;/region&gt;

Exercise 4.1: The code below will set up an element range index on 
the &lt;region&gt; element, with type=string.
:)

xquery version "1.0-ml";
import module namespace admin = "http://marklogic.com/xdmp/admin" 
         at "/MarkLogic/admin.xqy";
         
let $config := admin:get-configuration()

let $new-index := admin:database-range-element-index(
  "string", 
  "","region", 
  "http://marklogic.com/collation/",
  fn:false()
)

let $new-config := admin:database-add-range-element-index(
  $config, xdmp:database("mlw16-geo-wkshp"), $new-index)

return admin:save-configuration($new-config)
</query><query name="exercise-4.2.sjs" focus="false" listorder="38" taborder="37" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Exercise 4.2: Use cts.matchRegions to find all regions in the 
database that intersect the polygon (in WKT):
POLYGON((-122.41533279418945 37.78064679009218,-122.43043899536133 37.75594988363168,-122.38632202148438 37.75649276142684,-122.3931884765625 37.781460833378034,-122.41533279418945 37.78064679009218))
*/

var poly = cts.parseWkt("POLYGON((-122.41533279418945 37.78064679009218,-122.43043899536133 37.75594988363168,-122.38632202148438 37.75649276142684,-122.3931884765625 37.781460833378034,-122.41533279418945 37.78064679009218))")
var index = cts.elementReference(xs.QName("region"))

cts.matchRegions(index, "intersects", poly)</query><query name="exercise-4.3.sjs" focus="false" listorder="40" taborder="39" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">/*
Much like the cts.*ValueMatch lexicon functions, cts.matchRegions 
returns the regions themselves. To obtain the WKT strings, use the 
"strings" option to cts:matchRegions.

If you want to retrieve the documents containing the matching 
regions, use these strings to construct a cts.jsonPropertyRangeQuery
to find the documents containing the WKT strings.

Exercise 4.3: Find all documents in the database whose "region" 
intersects the polygon:
POLYGON((-122.41533279418945 37.78064679009218,-122.43043899536133 37.75594988363168,-122.38632202148438 37.75649276142684,-122.3931884765625 37.781460833378034,-122.41533279418945 37.78064679009218))
*/

var poly = cts.parseWkt("POLYGON((-122.41533279418945 37.78064679009218,-122.43043899536133 37.75594988363168,-122.38632202148438 37.75649276142684,-122.3931884765625 37.781460833378034,-122.41533279418945 37.78064679009218))");

var wktStrings = cts.matchRegions(cts.elementReference(xs.QName("region")), "intersects", poly, ["strings"]);

var qry = cts.jsonPropertyRangeQuery("region", "=", wktStrings);
cts.search(qry);</query><query name="Sample Data" focus="true" listorder="1" taborder="1" active="true" database="9059189350391337657" server="3157198157855269707" mode="javascript">
// School data
var school = fn.doc("/schools-points/sf-public-schools-points.kml-0-109.xml");

// Crime data 
var crime = fn.doc("/crime-points/sf-2015-crime-points.xml-0-118730.xml");

// Benches &amp; Picnic tables 
var bench = fn.doc("/benches/benches-points-16317649215586544036.json");
var picnicTable = fn.doc("/picnic-tables/picnic-tables-points-4803263452428296981.json");

// Bike paths 
var bikepath = fn.doc("/bikeway-network/bikepaths-linestrings-7072575054613262216.json");

// Realtor neighborhoods
var neighborhood = fn.doc("/realtor-neighborhood/neighborhood-polygon-3803868776378775358.json");

var array = [school, crime, bench, picnicTable, bikepath, neighborhood];

xdmp.arrayValues(array);</query></workspace></export>
